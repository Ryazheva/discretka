def count_paths(m, n):
    # Создаем 2D-массив (список списков) dp размером (m+1) x (n+1), заполненный нулями.
    # dp[i][j] будет хранить количество путей для достижения клетки (i, j) в сетке.
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # Устанавливаем базовое значение: есть 1 путь для достижения начальной клетки (0, 0).
    dp[0][0] = 1

    # Итерируемся по всем клеткам сетки, чтобы заполнить значения в dp.
    for i in range(m + 1):
        for j in range(n + 1):
            # Если мы можем прийти в текущую клетку (i, j) из клетки над ней (i-1, j)
            if i > 0:
                # Добавляем количество путей до клетки над ней, чтобы получить количество путей до текущей клетки.
                dp[i][j] += dp[i - 1][j]
            # Если мы можем прийти в текущую клетку (i, j) из клетки слева от нее (i, j-1)
            if j > 0:
                # Добавляем количество путей до клетки слева, чтобы получить количество путей до текущей клетки.
                dp[i][j] += dp[i][j - 1]

    # После заполнения всей таблицы dp, возвращаем количество путей до конечной клетки (m, n).
    return dp[m][n]


def count_paths_with_constraint(x, y, last_move, memo):
    # Если мы достигли конечной клетки (18, 0), это значит что мы нашли валидный путь.
    if x == 18 and y == 0:
        return 1  # Возвращаем 1, потому что нашли один путь

    # Если мы вышли за границы сетки, то это невалидный путь.
    if x > 18 or y < 0:
        return 0 #Возвращаем 0, показывая, что данный путь не валиден.

    # Проверяем, сохраняли ли мы уже результат для данной комбинации (x, y, last_move).
    if (x, y, last_move) in memo:
        return memo[(x, y, last_move)] #Если сохраняли, то берем сохраненное значение.

    # Инициализируем счетчик путей, начинающийся с этой позиции.
    paths = 0

    # Рекурсивно двигаемся вправо (увеличиваем x). Отмечаем шаг как горизонтальный ('H').
    paths += count_paths_with_constraint(x + 1, y, 'H', memo)

    # Рекурсивно двигаемся вверх (уменьшаем y), только если предыдущий шаг не был вертикальным ('V').
    if last_move != 'V':
        paths += count_paths_with_constraint(x, y - 1, 'V', memo)

    # Сохраняем количество путей, найденных для текущей комбинации (x, y, last_move) в memo.
    memo[(x, y, last_move)] = paths
    return paths #Возвращаем общее количество путей, которое начинается с этой позиции.


# Устанавливаем размеры сетки: m=18 (количество шагов вниз), n=18 (количество шагов вправо).
m, n = 18, 18
# Инициализируем пустой словарь memo для мемоизации.
memo = {}
# Вызываем рекурсивную функцию, чтобы вычислить количество путей с ограничением, начиная с позиции (0, 18).
result = count_paths_with_constraint(0, 18, '', memo)

# Выводим результаты
print("Количество кратчайших путей:", count_paths(m, n)) #Выводит общее число кратчайших путей в сетке m x n.
print("Количество путей с ограничением:", result) #Выводит число кратчайших путей в сетке m x n, где запрещены 2 последовательных вертикальных шага.
